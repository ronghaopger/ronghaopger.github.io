<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hulk' Den</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 28 Mar 2019 15:13:10 +0800</pubDate>
    <lastBuildDate>Thu, 28 Mar 2019 15:13:10 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>UIButton设置不同状态下的纯色背景图片的最优方案探讨</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;小组同学最近在封装一组自定义的UIKit控件，目的是做到比UIKit更易用高性能，今天初步读了部分实现代码，发现以下细节：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//基于CoreGraphics根据传入的UIColor绘制并生成UIImage。
+ (UIImage *)imageWithColor:(UIColor *)color {
    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;达到的目的就是用户只需要关注&lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlStateNormal&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlStateHighlighted&lt;/code&gt;状态下期望的background color，我们在内部来生成UIImage并通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setBackgroundImage:forState:&lt;/code&gt;来设置。（只适用于用户期望设置纯色背景的场景）&lt;/p&gt;

&lt;p&gt;易用性做到了，性能方面却损失了。（我所遇到的）大多数卡顿场景的瓶颈往往在CPU，（在我之前的几篇关于优化性能的文章里有过讨论），而这段代码中的开辟内存空间，绘制内容再生成图片都是在CPU上进行，无疑是不理想的。那有没有更好的方案呢？&lt;/p&gt;

&lt;h2 id=&quot;思路一借助touch-delivery-methods&quot;&gt;思路一：借助touch-delivery methods&lt;/h2&gt;
&lt;p&gt;牵扯到触控状态的改变时，我们通常选择重写&lt;code class=&quot;highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;touchesBegan:withEvent:&lt;/code&gt;等方法，几行代码的事儿，但是run起来以后发现跟系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlStateHighlighted&lt;/code&gt;效果还是有不同的，这个在我之前探索iOS触控响应部分的时候就发现了，如下：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/images/2018-06-15/normal.gif&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/images/2018-06-15/no.gif&quot; alt=&quot;&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;系统默认效果&lt;/td&gt;
      &lt;td&gt;我们实现的效果（注意Title因为是使用setTitle:forState:因此效果正常）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlStateHighlighted&lt;/code&gt;效果是有个范围的，但是这个范围apple并没有告诉我们，那这个方案就不完美了。更进一步我想测测这个范围到底是多少，是不是有一定规律呢？三下五除二，发现不论UIButton的size是多大，这个范围大概是(70, 70.5, 70, 70)，把这个范围控制逻辑写进&lt;code class=&quot;highlighter-rouge&quot;&gt;touchesMoved:withEvent:&lt;/code&gt;，效果跟系统的就一致了！代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    [super touchesBegan:touches withEvent:event];
    [self setBackgroundColor:self.backHighlightColor];
}

-(void)touchesMoved:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    [super touchesMoved:touches withEvent:event];
    
    UITouch *touch = touches.anyObject;
    CGPoint location = [touch locationInView:[UIApplication sharedApplication].keyWindow];
    CGFloat locationX = location.x;
    CGFloat locationY = location.y;
    //这里默认UIButton的superView是撑满屏幕的，还需完善。
    CGFloat originX = self.frame.origin.x;
    CGFloat originY = self.frame.origin.y;
    CGFloat width = self.frame.size.width;
    CGFloat height = self.frame.size.height;
    BOOL xInScope = (locationX &amp;lt;= originX &amp;amp;&amp;amp; originX - locationX &amp;lt; 70.5) || (locationX &amp;gt; originX &amp;amp;&amp;amp; locationX - originX - width &amp;lt; 70);
    BOOL yInScope = (locationY &amp;lt;= originY &amp;amp;&amp;amp; originY - locationY &amp;lt; 70) || (locationY &amp;gt; originY &amp;amp;&amp;amp; locationY - originY - height &amp;lt; 70);
    if (xInScope &amp;amp;&amp;amp; yInScope) {
        [self setBackgroundColor:self.backHighlightColor];
    }
    else {
        [self setBackgroundColor:self.backNormalColor];
    }
}

-(void)touchesEnded:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    [super touchesEnded:touches withEvent:event];
    [self setBackgroundColor:self.backNormalColor];
}

-(void)touchesCancelled:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    [super touchesCancelled:touches withEvent:event];
    [self setBackgroundColor:self.backNormalColor];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;虽然效果一致了，但是显然并不能用于生产环境，因为(70, 70.5, 70, 70)这组边界值完全是我自己测量的，一是可能有些场景我没有覆盖到，二是指不定哪天apple就把这个值改变了，总之这个思路是不可靠的。&lt;/p&gt;

&lt;h2 id=&quot;思路二借助kvo观察uibutton的highlighted变化&quot;&gt;思路二：借助KVO观察UIButton的highlighted变化&lt;/h2&gt;
&lt;p&gt;经过思路一，我发现一定要寻找一个可靠的参考量。自然而然KVO涌上心头，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self addObserver:self forKeyPath:@&quot;highlighted&quot; options:NSKeyValueObservingOptionNew context:nil];

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change context:(void *)context {
    if ([keyPath isEqualToString:@&quot;highlighted&quot;]) {
        BOOL highlighted = change[NSKeyValueChangeNewKey];
        UIColor *backgroundColor = highlighted ? self.backHighlightColor : self.backNormalColor;
        [self setBackgroundColor:backgroundColor];
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;经过测试，跟&lt;code class=&quot;highlighter-rouge&quot;&gt;思路一&lt;/code&gt;有同样的问题，highlighted属性在touchDown之后touchEnd之前一直都是YES，也忽略了范围条件。&lt;/p&gt;

&lt;h2 id=&quot;思路三借助kvo观察uibutton上的backgroundimageview的image变化&quot;&gt;思路三：借助KVO观察UIButton上的backgroundImageView的image变化&lt;/h2&gt;
&lt;p&gt;还是没有找到可靠而又准确的参考量，再想想，其实我们直观看到的就是最准确的，UIButton是随着&lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlStateNormal&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlStateHighlighted&lt;/code&gt;的变化来切换UIImageView的image（经验证这部分逻辑在UIButton的&lt;code class=&quot;highlighter-rouge&quot;&gt;touchesMoved:withEvent:&lt;/code&gt;中），通过观察视图层级我们得知UIButton上有两个UIImageView和一个UILabel，分别来承载UIButton的title、image和backgroundImage，那么承载backgroundImage的那个UIImageView的image属性就是我们要找的那个可靠而又准确的参考量。&lt;/p&gt;

&lt;p&gt;突破点有了，整理思路如下：&lt;/p&gt;

&lt;h3 id=&quot;1触发uibutton添加所需的background--uiimageview&quot;&gt;1、触发UIButton添加所需的background  UIImageView&lt;/h3&gt;
&lt;p&gt;当我们调用UIButton的&lt;code class=&quot;highlighter-rouge&quot;&gt;setBackgroundImage:forState:&lt;/code&gt;时，UIButton就会&lt;code class=&quot;highlighter-rouge&quot;&gt;addSubview:&lt;/code&gt;所需的UIImageView（如需），同理&lt;code class=&quot;highlighter-rouge&quot;&gt;setImage:forState:&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;setTitle:forState&lt;/code&gt;都有类似的逻辑，当UIButton上有多个UIImageView时我们就不容易区分它们了，因此我们的思路就是&lt;strong&gt;尽早的&lt;/strong&gt;触发&lt;code class=&quot;highlighter-rouge&quot;&gt;setBackgroundImage:forState:&lt;/code&gt;便于锁定我们的目标UIImageView，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        //保证最先执行
        //zombie_normal(1px x 1px)和zombie_highlighted(1px x 2px)为两张透明的占位图。
        self.buttonBackgroundNormalImage = [UIImage imageNamed:@&quot;zombie_normal&quot;];
        self.buttonBackgroundHighlightedImage = [UIImage imageNamed:@&quot;zombie_highlighted&quot;];
        [self setBackgroundImage:self.buttonBackgroundNormalImage forState:UIControlStateNormal];
        [self setBackgroundImage:self.buttonBackgroundHighlightedImage forState:UIControlStateHighlighted];
        [self setNeedsLayout];
        [self layoutIfNeeded];
    }
    return self;
}

/*
 * 重写以达到记录用户设置的background image
 */
- (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state {
    [super setBackgroundImage:image forState:state];
    if (state == UIControlStateNormal) {
        _buttonBackgroundNormalImage = image;
    }
    else if (state == UIControlStateHighlighted) {
        _buttonBackgroundHighlightedImage = image;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2锁定background-uiimageview&quot;&gt;2、锁定background UIImageView&lt;/h3&gt;
&lt;p&gt;触发&lt;code class=&quot;highlighter-rouge&quot;&gt;addSubview:&lt;/code&gt;之后，紧接着就是锁定这个被添加的UIImageView。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)layoutSubviews {
    [super layoutSubviews];
    [self findBackgroundImageView];
}

- (void)findBackgroundImageView {
    //不考虑用户去主动移除UIButton上的UIImageView，那么这个UIImageView一经确定就不会改变了。
    if (self.buttonBackgroundImageView) {
        return;
    }
    for (UIView *subview in self.subviews) {
        if ([subview isMemberOfClass:[UIImageView class]]) {
            self.buttonBackgroundImageView = (UIImageView*)subview;
            break;
        }
    }

    、、、
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3添加kvo跟踪变化&quot;&gt;3、添加KVO跟踪变化&lt;/h3&gt;
&lt;p&gt;锁定之后，添加KVO观察其image属性的变化，根据不同的image设置不同的background color。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void * BackgroundImageViewContext = &amp;amp;BackgroundImageViewContext;

- (void)findBackgroundImageView {
    、、、

    @try {
        [self.buttonBackgroundImageView removeObserver:self forKeyPath:@&quot;image&quot; context:BackgroundImageViewContext];
    } @catch (NSException *exception) {
    }
    [self.buttonBackgroundImageView addObserver:self forKeyPath:@&quot;image&quot; options:NSKeyValueObservingOptionNew context:BackgroundImageViewContext];
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change context:(void *)context {
    if (context == BackgroundImageViewContext &amp;amp;&amp;amp; [keyPath isEqualToString:@&quot;image&quot;]) {
        UIImage *newImage = change[NSKeyValueChangeNewKey];
        if ([newImage isEqual:self.buttonBackgroundNormalImage]) {
            [self setBackgroundColor:self.backNormalColor];
        }
        else if ([newImage isEqual:self.buttonBackgroundHighlightedImage]) {
            [self setBackgroundColor:self.backHighlightColor];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就达到了我们的目的，满足易用性并兼顾性能。&lt;/p&gt;

&lt;p&gt;一次有趣的探索，感谢阅读~&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Jun 2018 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/UIButton%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E6%8E%A2%E8%AE%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/UIButton%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E7%BA%AF%E8%89%B2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E6%8E%A2%E8%AE%A8/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>尊重自己</title>
        <description>&lt;h2 id=&quot;从一个兴趣说起&quot;&gt;从一个兴趣说起&lt;/h2&gt;
&lt;p&gt;我为什么喜欢踢球？&lt;/p&gt;

&lt;p&gt;因为我喜欢踢球过程中的&lt;strong&gt;操控&lt;/strong&gt;、&lt;strong&gt;组织&lt;/strong&gt;和&lt;strong&gt;超越&lt;/strong&gt;的感觉，让我兴奋。相比而言，赢球都不能带来这种兴奋。&lt;/p&gt;

&lt;p&gt;所以我宁愿踢中场不赢球，也不愿意踢后卫赢球（当然只是打个比方，我踢中场反而更容易赢球）。所以就得出了不让我踢中场，我宁愿不去踢球的原因。也得出了为什么我喜欢小罗齐祖，而不喜欢大罗C罗梅西。&lt;/p&gt;

&lt;p&gt;再进一步分析，是因为&lt;strong&gt;操控&lt;/strong&gt;满足我的控制欲，并让我获得安全感，&lt;strong&gt;组织&lt;/strong&gt;是我对美好事物的追求（有条不紊的进攻和防守），&lt;strong&gt;超越&lt;/strong&gt;让我获得成就感。&lt;/p&gt;

&lt;p&gt;再进一步分析，不论是控制欲、安全感、成就感还是对美好事物的追求，都让我获得快乐。也就是获得快乐才是根源，更加可以肯定的是人活着就是为了尽可能的获得快乐。&lt;/p&gt;

&lt;h2 id=&quot;兴趣是什么&quot;&gt;兴趣是什么&lt;/h2&gt;
&lt;p&gt;我们对某事物感&lt;strong&gt;兴趣&lt;/strong&gt;，是因为我们潜意识里认为此事物（可能）会满足我们的某种欲望或某种感觉。我们每个人都需要这些欲望和感觉，只是对每种欲望或感觉的需要程度不一样，不同的人把等分量的成就感转化成的快乐量也不同。因此我们有不同的兴趣爱好。&lt;/p&gt;

&lt;p&gt;有句话说有些事情你不去尝试，你就永远不知道自己对它是否感兴趣。也确实是这样，一个最常见的例子，我们周围的篮球群众是要多于足球群众的，上学的时候就能发现，因为对于一个新人来说，他更容易上手篮球（因为是用我们最熟练的手去操作），也更容易投进一粒球获得成就感，球场也比较小能更快的完成进攻，所以一个新人在玩篮球时能更快的感受到欲望和感觉的满足，因此篮球更易产生兴趣。但是不代表这位新人对足球不感兴趣，或许经过尝试之后会更喜欢足球，足球能给一些篮球给不了的欲望和感觉（反之亦然）。当然也有可能这两项他都不喜欢。&lt;/p&gt;

&lt;h2 id=&quot;兴趣是可以培养的&quot;&gt;兴趣是可以培养的&lt;/h2&gt;
&lt;p&gt;从以上论述也可以得出，兴趣是我们的认知和实践综合后的结果，而欲望和感觉是我们的本能反应。&lt;/p&gt;

&lt;p&gt;本能反应是没法培养的，比如人需要成就感这个东西，但是人不会需要一个xy感（瞎起的名字）。但是我认为经过不断的刺激，我们对每种欲望和感觉的需要程度是会变化的。 比如一直让你练习美术，你或许对美好事物的需求会变的强烈；一直让你练习投篮，你或许对成就感的需求会变的强烈。当然只是或许，因为每个人的本能需求情况应该受很多因素影响，最基本的比如身体状况差异。&lt;/p&gt;

&lt;p&gt;兴趣是可以培养的，有些事物是完全可以给你提供你偏好的那些欲望和感觉的，只需要假以时日去尝试体会，你就会培养出一个深厚的兴趣。有些事物提供的欲望和感觉并不能很好的迎合你当前的本能偏好，就像上一段所阐述的，如果你愿意，也可以去尝试刺激一下，算是遇见新的你：）当然可能会培养失败。&lt;/p&gt;

&lt;h2 id=&quot;好奇心是可以被扼杀的&quot;&gt;好奇心是可以被扼杀的&lt;/h2&gt;
&lt;p&gt;好奇心就是一种本能的欲望，每个人都具有，当然程度也不一样。&lt;/p&gt;

&lt;p&gt;就像上一节说的，不断的刺激是会改变我们对每种欲望和感觉的需要程度的。平时生活中太多例子了，小朋友对雪花的好奇心可能会因为妈妈怕他被冻着而不许外出被扼杀，或者因为妈妈哪怕不懂雪花产生的原理却都没有多一点耐心去引导探索取而代之的是让乖乖听话而被扼杀。我们一生中或者因为妈妈，或者因为生长的环境，或者只是因为自己的懒惰（我甚至觉得懒惰都是好奇心等一些本能被扼杀导致的），都在扼杀好奇心。&lt;/p&gt;

&lt;p&gt;没有好奇心世界就会停滞不前。好奇心不可以被扼杀，其他的欲望和感觉也不能被扼杀。&lt;/p&gt;

&lt;h2 id=&quot;自己&quot;&gt;自己&lt;/h2&gt;
&lt;p&gt;因为一些自己的经历，在这个时间段有了这些感悟，总结记录下来升华自己。都是过往，谁能不受生活的洗礼呢。&lt;/p&gt;

&lt;p&gt;认识自己，尊重自己，人生才会自由快乐。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Mar 2018 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/%E5%B0%8A%E9%87%8D%E8%87%AA%E5%B7%B1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/%E5%B0%8A%E9%87%8D%E8%87%AA%E5%B7%B1/</guid>
        
        <category>感悟</category>
        
        
      </item>
    
      <item>
        <title>iOS触控响应中那些没有细想过的问题</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;写在前面：这篇文章的重点在于讨论我想到的一些关于iOS触控响应这块容易忽略的问题，限于篇幅就不对基本的iOS触控响应知识做说明了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一ios给我们提供的响应触控的方式&quot;&gt;一、iOS给我们提供的响应触控的方式&lt;/h2&gt;
&lt;h3 id=&quot;1the-touch-delivery-methods&quot;&gt;1、The touch-delivery methods&lt;/h3&gt;
&lt;p&gt;定义在UIResponder中的以下方法，通过重写可以实现自定义的触控响应逻辑。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(nullable UIEvent *)event;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2uicontrol&quot;&gt;2、UIControl&lt;/h3&gt;
&lt;p&gt;即&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html&quot;&gt;Target-Action&lt;/a&gt;模式，具体支持的事件在&lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlEvents&lt;/code&gt;枚举中有定义。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;
- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;
- (void)endTrackingWithTouch:(nullable UITouch *)touch withEvent:(nullable UIEvent *)event;
- (void)cancelTrackingWithEvent:(nullable UIEvent *)event;

- (void)sendActionsForControlEvents:(UIControlEvents)controlEvents;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以通过重写这四个tracking方法结合sendActionsForControlEvents:方法实现事件的自定义逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: 
或许有人会有疑问说这四个tracking方法跟UIResponder中的四个touch-delivery methods方法很像，有什么区别呢？下文中的&lt;strong&gt;结论三&lt;/strong&gt;会讲到。&lt;/p&gt;

&lt;h3 id=&quot;3uigesturerecognizer&quot;&gt;3、UIGestureRecognizer&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;UILongPressGestureRecognizer  长按&lt;/li&gt;
  &lt;li&gt;UIPanGestureRecognizer  拖动&lt;/li&gt;
  &lt;li&gt;UIPinchGestureRecognizer  缩放&lt;/li&gt;
  &lt;li&gt;UIRotationGestureRecognizer  旋转&lt;/li&gt;
  &lt;li&gt;UISwipeGestureRecognizer  轻扫&lt;/li&gt;
  &lt;li&gt;UITapGestureRecognizer  点击&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们也可以继承UIGestureRecognizer，通过重写touch-delivery methods来自定义一个新手势。&lt;/p&gt;

&lt;h2 id=&quot;二为什么是多种方式&quot;&gt;二、为什么是多种方式&lt;/h2&gt;
&lt;p&gt;那么让我好奇的是为什么要提供三种方式呢？比如最常见的点击操作，通过上述三种方式都可以响应，那到底用哪种呢？为何不统一成一种方式呢？&lt;/p&gt;

&lt;p&gt;我的理解，UIControl的出现是为了更好的封装性，把具有一些特定行为的UIView封装成控件，方便复用。而且通过demo实验可知，UIControl中对于UIControlEvents中定义的事件的支持，其实就是通过重写UIResponder中的touch-delivery methods实现的，不过加了一些&lt;strong&gt;特殊的逻辑&lt;/strong&gt;（下文会提到）。&lt;/p&gt;

&lt;p&gt;而UIGestureRecognizer是&lt;code class=&quot;highlighter-rouge&quot;&gt;NS_CLASS_AVAILABLE_IOS(3_2)&lt;/code&gt;加入的机制，我认为这是Apple对UIView的触控响应部分的解耦。同时，还有很重要的一点是UIGestureRecognizer的&lt;strong&gt;优先级是最高的&lt;/strong&gt;，这个在网上很多关于触控响应的资料都有说明，下文中有我对于这块代码的实现猜想。&lt;/p&gt;

&lt;h2 id=&quot;三多种方式带来的混乱&quot;&gt;三、多种方式带来的混乱&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;为了便于对下文场景的描述我们约定一下简称：&lt;br /&gt;
UIView统一用view&lt;br /&gt;
UIScrollView统一用scrollView&lt;br /&gt;
UIButton统一用button&lt;br /&gt;
UITextField统一用textField&lt;br /&gt;
UIGestureRecognizer统一用gesture&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：下文中描述的存在上下层级关系的view，都存在包含关系（即上层view都是addSubView到下层view上的）。显然，如果不存在包含关系，就不在一个响应链上，也就不需要讨论了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;scrollViewA 上方有一个viewA，滑动viewA，scrollViewA会不会被滑动呢？它们的touch-delivery methods会触发吗？&lt;/li&gt;
  &lt;li&gt;scrollViewA上方有一个scrollViewB，滑动scrollViewB，scrollViewA会不会被滑动呢？它们的touch-delivery methods会触发吗？&lt;/li&gt;
  &lt;li&gt;buttonA上方有一个viewA，点击viewA，buttonA会响应吗？它们的touch-delivery methods会触发吗？&lt;/li&gt;
  &lt;li&gt;buttonA上方有一个buttonB，点击buttonB，buttonA会响应吗？它们的touch-delivery methods会触发吗？&lt;/li&gt;
  &lt;li&gt;viewA viewB viewC依次从下到上， viewA和viewB都addGestureRecognizer:tapGesture，那么点击viewC，viewA和viewB上的手势(都)会被触发吗？它们的touch-delivery methods会触发吗？&lt;/li&gt;
  &lt;li&gt;还是(5)这种场景，如果viewC是一个button，会怎样呢？&lt;/li&gt;
  &lt;li&gt;buttonA上addGestureRecognizer:tapGesture，同时还addTarget:action:forControlEvents:UIControlEventTouchDown，在用户点击的时候它们都会被识别并触发吗？如果是UIControlEventTouchUpInside事件又会这样呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;相信这些情况在一些复杂的业务场景中是可能碰到的，也会带来困惑。从下文中就可以找到答案了，我是通过最初的猜想，到自己写demo实验，得出的以下结论。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;四从猜想到实验得出的结论&quot;&gt;四、从猜想到实验得出的结论&lt;/h2&gt;
&lt;h3 id=&quot;结论一uiresponder实现了uitouch的传递&quot;&gt;结论一：UIResponder实现了UITouch的传递&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIResponder&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;touchesBegan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITouch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;touches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextResponder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesBegan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;也就是我们重写touch-delivery methods时，如果不调用父类的实现，就会阻断UITouch的传递。&lt;/p&gt;

&lt;h3 id=&quot;结论二uicontrol阻断了uitouch的传递&quot;&gt;结论二：UIControl阻断了UITouch的传递&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIControl&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;touchesBegan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITouch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;touches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//没有调用下面这句
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//[super touchesBegan:touches withEvent:event];
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;基于结论一，再加以实验发现，UIControl在实现touch-delivery methods时就没有调用父类的实现，因此&lt;strong&gt;UIControl以及它的子类&lt;/strong&gt;都会阻断UITouch的传递。&lt;/p&gt;

&lt;h3 id=&quot;结论三uicontrolevents只会在此uicontrol是用户触摸的view时才会被触发&quot;&gt;结论三：UIControlEvents只会在此UIControl是用户触摸的view时才会被触发&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIControl&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;touchesBegan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITouch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;touches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UITouch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;anyObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//TODO: UIControlEvents中定义的事件的识别逻辑
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;beginTrackingWithTouch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//其它几个方法逻辑类似
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;UIControl只有在hitTest:withEvent:方法最终返回的view是自己的时候，即用户真正触摸的view是自己的时候，才会触发响应。这样描述是为了说明，虽然UIControl也是继承了UIResponder并重写touch-delivery methods来实现触控响应逻辑，但是如果它不是在响应链的最外端，那么UIControlEvents事件并不会被触发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:
可能有人会有疑问，代码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;//TODO: UIControlEvents中定义的事件的识别逻辑&lt;/code&gt;为什么是在touchesBegan:withEvent:方法中实现？而不是封装到beginTrackingWithTouch:withEvent:中去？我也是经过实验得出的这个结论，我的理解是如果按后者来，那么我们在重写beginTrackingWithTouch:withEvent:方法时如果没有调用父类的实现，就使它失去了在父类里已经明确声明的对于UIControlEvents的支持，是不合理的，Apple如此设计做到了功能的一致性。（其实本该如此，只是我在猜想代码实现的的小想法而已）&lt;/p&gt;

&lt;h3 id=&quot;结论四uibutton会阻断superviews上的手势识别&quot;&gt;结论四：UIButton会阻断superViews上的手势识别&lt;/h3&gt;
&lt;p&gt;我们知道手势响应的优先级是最高的，默认情况下，在UITouch的目标view及其superView上的gestureRecognizers被识别时，会调用目标view及其superView的touchesCancelled:withEvent:方法来取消响应链对于此UITouch的响应。除非把UIGestureRecognizer的cancelsTouchesInView属性设为NO。&lt;/p&gt;

&lt;p&gt;但是有没有想过同样依赖touch-delivery methods来实现响应的UIButton跟比如UITapGestureRecognizer同时存在时，是怎样的响应逻辑呢？&lt;/p&gt;

&lt;p&gt;直接上我通过实验后的猜想代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIWindow&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sendEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UITouch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;allTouches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UITouch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;anyObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subviews&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CGPoint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;locationInView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hitTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//收集目标view及其superView的所有手势
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;collectGestureRecognizersWithLeafView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//触发响应
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;touch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITouchPhaseBegan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIGestureRecognizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesBegan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesBegan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITouchPhaseMoved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIGestureRecognizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesMoved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesMoved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITouchPhaseCancelled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIGestureRecognizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesCancelled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesCancelled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UITouchPhaseEnded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIGestureRecognizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureReconizer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesEnded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touchesEnded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allTouches&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIGestureRecognizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collectGestureRecognizersWithLeafView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;leafView&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSMutableArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSMutableArray&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leafView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isKindOfClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIButton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObjectsFromArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leafView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;superView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leafView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;superView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObjectsFromArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;superView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;superView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;superView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;superview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gestureRecognizers&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是如果UITouch的目标view是UIButton（也就是UIButton处在响应链的最外端），那么只有添加到这个UIButton上的手势会被识别，其余superViews上的手势都不会被识别。&lt;/p&gt;

&lt;h3 id=&quot;结论五默认情况下比如uilongpressgesturerecognizer这种不能在uitouchphasebegan阶段就识别的手势并不会影响uitouch的目标view以及其superview的touchesbeganwithevent方法的调用除非把uigesturerecognizer的delaystouchesbegan属性设为yes&quot;&gt;结论五：默认情况下，比如UILongPressGestureRecognizer这种不能在UITouchPhaseBegan阶段就识别的手势，并不会影响UITouch的目标view以及其superView的touchesBegan:withEvent:方法的调用。除非把UIGestureRecognizer的delaysTouchesBegan属性设为YES。&lt;/h3&gt;
&lt;p&gt;我们在&lt;strong&gt;结论四&lt;/strong&gt;里面对于UIWindow部分实现代码的猜想其实也能说明这一点，欠缺的是没有涉及对delaysTouchesBegan逻辑的猜想。&lt;/p&gt;

&lt;h3 id=&quot;结论六这一点算是基础知识关于响应链上有多个手势存在的场景其实就是对于uigesturerecognizerdelegate的应用&quot;&gt;结论六：这一点算是基础知识，关于响应链上有多个手势存在的场景，其实就是对于UIGestureRecognizerDelegate的应用。&lt;/h3&gt;
&lt;p&gt;UIGestureRecognizerDelegate里有详细的注释说明，熟练掌握就可以灵活应对响应链上有多种手势存在的场景。&lt;/p&gt;

&lt;h3 id=&quot;结论七这一点也不是本文关注的重点是我先前猜想的uiview的hittestwithevent方法的实现逻辑顺带贴出来便于理解这部分&quot;&gt;结论七：这一点也不是本文关注的重点，是我先前猜想的UIView的hitTest:withEvent:方法的实现逻辑，顺带贴出来便于理解这部分。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (UIView*)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event {
    //1、
    if (self.userInteractionEnabled == NO
        || self.alpha == 0.0
        || self.hidden == YES) {
        return nil;
    }


    //2、
    if ([self pointInside:point withEvent:event] == NO) {
        return nil;
    }

    //3、
    UIView *result = nil;
    for (UIView *view in self.subviews) {
        result = [view hitTest:point withEvent:event];
    }

    //4、
    return result ? result : self;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;写到这里必须声明，以上我说的都是错的。贴出来是希望跟大家交流学习，共同思考进步，阅读愉快！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：
&lt;a href=&quot;https://xidazheng.com/2016/10/21/how-ios-handles-touches-responder-chain-touch-event-handling-gesture-recognizers-scrollviews/&quot;&gt;How iOS handles touches. Responder chain, touch event handling, gesture recognizers, scrollviews – Xida Zheng&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Dec 2017 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/iOS%E8%A7%A6%E6%8E%A7%E5%93%8D%E5%BA%94%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%B2%A1%E6%9C%89%E7%BB%86%E6%83%B3%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/iOS%E8%A7%A6%E6%8E%A7%E5%93%8D%E5%BA%94%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%B2%A1%E6%9C%89%E7%BB%86%E6%83%B3%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>对各模块间的互斥关系管理的小思考</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近在项目中遇到这样一个场景，在直播间的主播端有个功能区，里面是一些插件，这些插件之间在业务上存在互斥关系，也就是A处于开启状态时，B、C、D、E甚至是甲乙丙丁都不能打开。随着这块业务的增多，由于没有及时重构，导致互斥逻辑写的很是让人抓狂。&lt;/p&gt;

&lt;p&gt;假设有A、B、C、D四个互斥模块，当A要启动时，需要&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (B is running) {
    Log(&quot;B is running&quot;);
    return;
}
if (C is running) {
    Log(&quot;C is running&quot;);
    return;
}
if (D is running) {
    Log(&quot;D is running&quot;);
    return;
}
A.run();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其它几个模块类似，在需要启动时先去判断与自己互斥的模块是否正在运行。&lt;/p&gt;

&lt;h2 id=&quot;延伸&quot;&gt;延伸&lt;/h2&gt;
&lt;p&gt;这只是四者之间，其实实际的场景中还会有E、F、G、H、甲、乙、丙、丁，他们之间存在一定的互斥关系。那么可以想象在每个模块需要启动时，将会有一连串的互斥判断，而且不同的情况还需要有不同的提示（比如上边例子中的Log），很不优雅！如何优化呢？&lt;/p&gt;

&lt;h2 id=&quot;方法一锁的思路&quot;&gt;方法一：锁的思路&lt;/h2&gt;
&lt;p&gt;我想到了一个简单的模型，所有互斥模块间肯定至少存在一个互斥圈子，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12/circle.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们自定义一个锁结构:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Lock {
    bool isLocking;
    Map information; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个互斥圈子拥有一个Lock的实例lockA，这个圈子里任何一个模块启动时就锁住这个实例lockA，然后当这个圈子里的其它模块B要启动时，代码就变成了如下这样：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (lockA.isLocking == true) {
    Log(lockA.information...);
    return;
}
B.run();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过划分圈子，减少了判断逻辑，降低了模块之间的耦合度。这个模型在我遇到的场景中其实已经够用了，但是仔细想想，还是不够完美。比如模块A处于多个互斥圈子的话（也就意味着互斥关系比较负责，圈子比较多）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (lockA.isLocking == true) {
    Log(lockA.information...);
    return;
}
if (lockB.isLocking == true) {
    Log(lockB.information...);
    return;
}
if (lockC.isLocking == true) {
    Log(lockC.information...);
    return;
}
A.run();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;判断逻辑又多了起来，维护这样的关系容易出错，后期新加模块时的维护成本也很高。&lt;/p&gt;

&lt;h2 id=&quot;方法二互斥管理类作为中介&quot;&gt;方法二：互斥管理类作为中介&lt;/h2&gt;
&lt;p&gt;沿用 ~方法一~ 中互斥圈子的概念，我们抽象出来一个专门的互斥关系管理类，维护一个Map来记录互斥情况，Map的key用来区分不同互斥圈子。
类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-12-12/uml.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;伪代码实现如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class exclusionManager {
    Map&amp;lt;string,Array&amp;gt; map;

    public void add(IExclusive object) {
        Array array = object.belongList();
        foreach(string key in array) {
            map[key].add(object);
        }
    }

    public bool canRun(IExclusive object) {
        Array array = object.belongList();
        foreach(string key in array) {
            foreach(IExclusive object in map[key]) {
                if (object.isRunning == true)
                    return false;
            }
        }
        return true;
    }
}

class moduleA : IExclusive {
    public bool isRunning() {
        //TODO: 返回该模块是否正在运行的状态
        return ...;
    }
    
    public Array belongList() {
        //TODO：返回该模块所在的互斥圈子
        return [&quot;aCircle&quot;,&quot;bCircle&quot;,&quot;...&quot;];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样做降低模块间的耦合度，后期增删模块时也方便维护关系，算是一个不错的方案。&lt;/p&gt;

&lt;h3 id=&quot;用objective-c实现时的注意点&quot;&gt;用Objective-C实现时的注意点&lt;/h3&gt;
&lt;p&gt;再回到我们Objective-C实现上，例子中exclusionManager实例对module实例的强引用其实是不合理的，我们可以把map中用来存储module实例的数组做成一个弱引用数组，具体实现方式有两种：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方式一&lt;/strong&gt;：用不强引用的NSValue包装一下。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSValue *value = [NSValue valueWithNonretainedObject:...];
[array addObject:value];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;方式二&lt;/strong&gt;：为NSMutableArray扩展一个Category，通过Core Foundation的API来生成一个不会retain元素的数组。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (id)mutableArrayUsingWeakReferencesWithCapacity:(NSUInteger)capacity {
    CFArrayCallBacks callbacks = {0, NULL, NULL, CFCopyDescription, CFEqual};
    // We create a weak reference array
    return (id)CFBridgingRelease(CFArrayCreateMutable(0, capacity, &amp;amp;callbacks));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样算是解决了互斥管理难题，代码也优雅了很多。&lt;/p&gt;

&lt;p&gt;希望未来有新的想法可以继续改进，共勉！&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;https://stackoverflow.com/questions/9336288/nsarray-of-weak-references-unsafe-unretained-to-objects-under-arc/13351665&lt;/p&gt;

&lt;p&gt;https://stackoverflow.com/questions/4692161/non-retaining-array-for-delegates/4692229&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Dec 2017 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/%E5%AF%B9%E5%90%84%E6%A8%A1%E5%9D%97%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E5%85%B3%E7%B3%BB%E7%AE%A1%E7%90%86%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/%E5%AF%B9%E5%90%84%E6%A8%A1%E5%9D%97%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E5%85%B3%E7%B3%BB%E7%AE%A1%E7%90%86%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/</guid>
        
        <category>重构 | iOS</category>
        
        
      </item>
    
      <item>
        <title>类似逐帧动画或者tableView列表中有大量图片展示需求的场景我们可以做哪些优化？</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近公司在调研后打算替换掉老的识别库，据说新库在识别率上做的更好一些。但是在集成后实际压测发现并没有什么提升。（由于分析过程可能牵扯到公司业务，所以此处省略分析发现问题的过程，见谅）&lt;/p&gt;

&lt;p&gt;……….&lt;/p&gt;

&lt;p&gt;那么思路捋到这里我们可以总结出来两个至关重要的优化点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;避免频繁的解压资源包操作，每次解压绝对是件耗费的操作。这个是比较低级但在俯瞰全局时容易忽略的点，本篇不做讨论。&lt;/li&gt;
  &lt;li&gt;逐帧动画的图片数量比较大质量比较高，能否把PNG/JPEG图片解码成位图后保存到本地，避免CPU进行重复频繁的解码图片操作？基于这一点我们开始本篇的探讨。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;图片优化思路的来源和延伸&quot;&gt;图片优化思路的来源和延伸&lt;/h2&gt;
&lt;p&gt;为了提高APP界面流畅度引出的优化方法有很多，在图片优化方面有一个思路，就是提前异步解码图片的思路而不是官方UIKit采用的在图片提交给GPU之前由主线程同步解码，这个思路的鼻祖应该就是&lt;a href=&quot;https://github.com/facebookarchive/AsyncDisplayKit&quot;&gt;Facebook的ASDK&lt;/a&gt;了，国内的&lt;a href=&quot;https://github.com/ibireme/YYImage&quot;&gt;ibireme大神的YYImage&lt;/a&gt;也借鉴了这个思路。（文末的附录1是我从他们这里学到的强制解码图片的思路）&lt;/p&gt;

&lt;p&gt;但是面对逐帧动画这个变态的操作，我觉得提前异步解码并不能解决痛点，因为我们直播间的瓶颈在CPU，提前异步解码终归还是要每次解码，那能不能让解码的操作只做一次，把解码得到的位图缓存到本地，以后再用了就直接加载位图呢？在这之前，还是先来了解下iOS展示图片的过程吧。&lt;/p&gt;

&lt;h2 id=&quot;ios展示图片的过程&quot;&gt;iOS展示图片的过程&lt;/h2&gt;
&lt;p&gt;我们写代码时，用给定的图片初始化一个UIImage对象并赋值给UIImageView.image，就在屏幕上呈现出该图片了，那么这个展示过程的原理是怎样的呢？&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self.testImageView.image = [UIImage imageNamed:@“xxx.png”];&lt;/code&gt; 这时系统会去应用的mainBundle下寻找xxx.png，并生成一个CGImageRef指针指向它。&lt;/li&gt;
  &lt;li&gt;RunLoop的CATransaction捕捉到testImageView属性的变化，准备把数据提交给GPU来渲染。&lt;/li&gt;
  &lt;li&gt;在把模型图层树(modelLayer tree)的数据提交给渲染图层树(renderLayer tree)之前，CPU会加载PNG图片到内存，并把PNG解码成位图。&lt;/li&gt;
  &lt;li&gt;在OpenGL的驱动下，GPU把位图数据渲染到屏幕上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Note 1&lt;/strong&gt;: 第1步并不会加载图片到内存，更不会解码，我是通过以下代码验证的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSMutableArray *array = [NSMutableArray array];
    for (NSInteger i = 0; i &amp;lt; 100; i++) {
        [array addObject:[UIImage imageNamed:[NSString stringWithFormat:@&quot;xiongbao_%ld.png&quot;, (long)i]]];
    }
    self.imageView.animationImages = [array copy];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这段代码执行后通过Xcode没有观察到内存的变化，只有在真正要展示的时候（本例就是&lt;code class=&quot;highlighter-rouge&quot;&gt;[self.imageView startAnimating];&lt;/code&gt;），才会加载并解码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note 2&lt;/strong&gt;: 关于modelLayer tree、presentationLayer tree和renderLayer tree，Apple官方有文档解释，网上也有些解释。我的理解是我们平时通过UIView直接操作的就是modelLayer。在一个动画过程中真正起作用的是presentationLayer，这时modelLayer的属性值仅代表的是这个动画的终点值，所以在动画过程中我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer.presentationLayer&lt;/code&gt;才能获得正在动画中的layer。而renderLayer是负责渲染的，不论是modelLayer还是presentationLayer在真正需要渲染展示的时候需要把数据提交给renderLayer。&lt;/p&gt;

&lt;h2 id=&quot;png位图&quot;&gt;PNG？位图？&lt;/h2&gt;
&lt;p&gt;首先我们需要搞清楚一个概念，所谓PNG/JPEG都是在描述一种特定的文件格式，比如PNG它有自己的表示方法和压缩方法，图片格式的出现应该就是为了便于传输。不讨论利用硬件解码，GPU可以看作是一个只会并行高速渲染像素的傻子，它可搞不懂什么PNG格式JPEG格式，所以传输给GPU的应该是像素化后的数据。&lt;/p&gt;

&lt;p&gt;值得一提的是，一张在硬盘里100K大小的PNG图片，解码成位图后可能有1M多，位图的大小 = 图片分辨率的宽 x 图片分辨率的高 x 单个像素点所占的空间大小。&lt;/p&gt;

&lt;h2 id=&quot;文件io-vs-cpu解码&quot;&gt;文件IO VS CPU解码&lt;/h2&gt;
&lt;p&gt;那么问题来了：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用PNG图片 = 从本地读取100K数据 + CPU解码这100K数据。&lt;/li&gt;
  &lt;li&gt;使用位图 = 从本地读取1+M的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实就是文件IO与CPU运算的一次平衡。&lt;/p&gt;

&lt;p&gt;目前为止我并没有想到什么有效的方法可以精确测量iPhone手机应用读取1M数据的损耗和CPU解码100K数据的损耗，但是说到平衡就是在强调我们应用的瓶颈在哪里，目前我们的直播间在各种功能效果都打开的情况下CPU是瓶颈，CPU的高速运转带来了手机发烫和CPU主频下调，紧接着就是掉帧，所以能为CPU减负是当务之急。&lt;/p&gt;

&lt;h2 id=&quot;asdk之后的又一个惊喜&quot;&gt;ASDK之后的又一个惊喜&lt;/h2&gt;
&lt;p&gt;世界这么大，我们能想到的，往往已经有先行者。在我尝试做这次优化时，机缘巧合碰到了&lt;a href=&quot;https://github.com/path/FastImageCache&quot;&gt;FastImageCache&lt;/a&gt;，它带来的惊喜不亚于第一次碰到ASDK。所以接下来的优化思路会有借鉴FastImageCache的地方，膜拜学习吧。&lt;/p&gt;

&lt;h2 id=&quot;color-copied-images&quot;&gt;Color Copied Images&lt;/h2&gt;
&lt;p&gt;这是Xcode提供的检测工具Instruments中Core Animation工具下的一个检测点，字如其意：复制图片。FastImageCache并没有涉及这项优化，但在我看它的README时自然想到了这点，什么意思呢？&lt;/p&gt;

&lt;p&gt;上文中提到过，屏幕上的图片展示最终还是要靠GPU去渲染，具体如何去渲染牵扯到我们iOS框架的底层封装以及专门的图像渲染领域我们不做深究。
iOS渲染图像是通过OpenGL驱动GPU来做的，OpenGL有它所支持的颜色空间&lt;a href=&quot;https://en.wikipedia.org/wiki/Color_space&quot;&gt;Color Space&lt;/a&gt;如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;For color formats, there are more possibilities. GL_RED, GL_GREEN, and GL_BLUE represent transferring data for those specific components (GL_ALPHA cannot be used). GL_RG represents two components, R and G, in that order. GL_RGB and GL_BGR represent those three components, with GL_BGR being in reverse order. GL_RGBA and GL_BGRA represent those components; the latter reverses the order of the first three components. These are the only color formats supported (note that there are ways around that).&lt;br /&gt;
摘自OpenGL Wiki: https://www.khronos.org/opengl/wiki/Pixel_Transfer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可见OpenGL ES支持RGB BGR RGBA BGRA等颜色空间，那么当遇到它不支持的颜色空间时，就需要麻烦CPU先行转换成它所支持的颜色空间（转换过程必然带来开辟空间并写入数据的操作，也就是复制操作），就给CPU带来额外的负担，也就是Color Copied Images所在意的关键点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note 1&lt;/strong&gt;: 在探究这一点时，我去检测了我们的APP，发现项目中的一些图标的颜色空间采用了Gray即&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F&quot;&gt;灰度图像 - 维基百科，自由的百科全书&lt;/a&gt;，导致产生了复制图片的操作。这点我跟我们的设计同学确认过，他的回复是这种图片可能是早期用PS生成的，现在Sketch生成的图片都是RGB的，即使是黑白的图片。我觉得这个说法没有说服力，从原理上推测应该是为了控制图片的大小，因为灰度图像每个像素只占8bits，图片会小很多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note 2&lt;/strong&gt;:  我们一直在说OpenGL，其实严格的说在移动端设备上使用的应该是OpenGL ES，即OpenGL for Embedded Systems。OpenGL的嵌入式版本，算是OpenGL的一个子集。&lt;/p&gt;

&lt;h2 id=&quot;像素对齐&quot;&gt;像素对齐&lt;/h2&gt;
&lt;p&gt;这是FastImageCache关注的一个点（其实在Instruments中也有体现：Color Misaligned Images），大意就是比如CPU每次读取固定的8 bytes的数据，现在有一个41 bytes大小的文件，那么CPU就需要读取6次，并且第6次读取的8 bytes还需要做多余的处理（只取第1个byte），那么自然会给CPU带来了额外的负担。解决的方法就是把这个文件填充到48 bytes，同时填充位不能影响原文件内容。&lt;/p&gt;

&lt;p&gt;接下来我努力以相对专业的角度解释下，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;为什么CPU要每次读取8 bytes的数据呢？这个牵扯到CPU的cache line size，这篇&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;Data structure alignment - Wikipedia&lt;/a&gt;可以解决部分疑惑，也可以自行google。通过FastImageCache源码发现它针对iPhone给出的对齐值是64，在Apple官方我并没有找到A系列处理器的cache line size的信息，但看到过有讨论说是A9的cache line size为64。下面贴上FastImageCache这块的源码：
&lt;img src=&quot;/assets/images/2017-9-25/FastImageCache.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;位图数据用矩阵来表示，以二维数组的形式存储在内存中。注意看附录中那段强制解码图片的代码，CGBitmapContextCreate(…)方法有个参数就是bytesPerRow，即每行的字节数。FastImageCache做到了bytesPerRow的大小是64的整数倍，具体一点用它的原文来说应该是：&lt;code class=&quot;highlighter-rouge&quot;&gt;A properly aligned bytes-per-row value must be a multiple of 8 pixels × bytes per pixel. &lt;/code&gt;，不仅是8的整数倍，还是bytesPerPixel的整数倍，可以推理这么做的目的是可以保证每行都存放了完整的像素，不会让一个像素数据跨行存储，也是优化的一个点。&lt;/li&gt;
  &lt;li&gt;可能大家也会有个疑问，为什么是以图片的每行（即bytesPerRow）为单位要求对齐，而不是图片数据的整体呢？那是因为GPU渲染图片是以行为单位进行的，并且是多行并行渲染。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mmap&quot;&gt;MMAP&lt;/h2&gt;
&lt;p&gt;除了像素对齐，MMAP&lt;a href=&quot;https://en.wikipedia.org/wiki/Mmap&quot;&gt;MMAP - Wikipedia&lt;/a&gt;也是FastImageCache关注的一个点。&lt;/p&gt;

&lt;p&gt;这个优化点是什么意思呢？通常系统加载一张图片（或者别的文件），会先把图片从硬盘拷贝到内存中的内核空间，某个进程需要时再拷贝到该进程的用户空间，也就是进程加载一张图片的过程中发生了&lt;strong&gt;两次拷贝&lt;/strong&gt;，并且在另一个进程也需要访问该图片时还会从内核空间&lt;strong&gt;再拷贝&lt;/strong&gt;一份到它的用户空间（没有进程间共享内存）。&lt;/p&gt;

&lt;p&gt;而MMAP会把硬盘中的图片地址直接映射到进程的用户空间中，在进程访问图片数据时触发缺页中断&lt;a href=&quot;https://en.wikipedia.org/wiki/Demand_paging&quot;&gt;Demand paging - Wikipedia&lt;/a&gt;，才会把硬盘中的图片数据直接拷贝到内存中并更新页表，这样就只进行了&lt;strong&gt;一次拷贝&lt;/strong&gt;，并且在另一个进程也需要访问该图片触发缺页中断时，可以加载内存中已经更新的页表，实现&lt;strong&gt;内存共享&lt;/strong&gt;，同时可以想到的是内存共享带来了写入时需要加锁处理。&lt;/p&gt;

&lt;p&gt;那么可以得出结论，MMAP相较于传统的文件读取，减少了数据拷贝的次数，减小了内存消耗。尤其对于展示图片这种只读不写的场景尤为适用。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;回到开始，对于有展示大量图片需求的场景，有几个优化点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;直接使用位图。&lt;/li&gt;
  &lt;li&gt;避免使用OpenGL不支持的颜色空间。&lt;/li&gt;
  &lt;li&gt;保证图片数据内存对齐。&lt;/li&gt;
  &lt;li&gt;用MMAP代替传统的文件读取。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后还是要膜拜一下FastImageCache的库作者，感叹作为一名计算机工程师所拥有的知识面和基础功底的重要性，决定了我们在写代码时会去关注哪个层面的东西。&lt;/p&gt;

&lt;p&gt;共勉！&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;附录1&quot;&gt;附录1&lt;/h3&gt;
&lt;p&gt;为了膜拜这些领路人，我先贴一段从他们那里学来的iOS强制解码图片的思路，就是利用Core Graphics把图片绘制到一块开辟好的context上并保存成位图：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)createBitmapWithImage:(UIImage*)image {
    CGFloat scaleWidth = image.size.width * image.scale;
    CGFloat scaleHeight = image.size.height * image.scale;
    CGColorSpaceRef colorSpace = CGImageGetColorSpace(image.CGImage);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image.CGImage);
    //decode
    CGContextRef context = CGBitmapContextCreate(NULL, scaleWidth, scaleHeight, 8, scaleWidth * 4, colorSpace, alphaInfo);
    CGContextDrawImage(context, CGRectMake(0, 0, scaleWidth, scaleHeight), image.CGImage);
    CGImageRef bitmapImageRef = CGBitmapContextCreateImage(context);
    //release
    CGColorSpaceRelease(colorSpace);
    CGContextRelease(context);
    CGImageRelease(bitmapImageRef);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2018.6.12更新：在最近的一次项目实践中，对附录1这块内容有了新的理解，因此补充一下。&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;update附录1&quot;&gt;Update附录1&lt;/h3&gt;
&lt;p&gt;除了附录1中的方法，还有一种方式可以对图片进行（提前）解码，即通过CGImageSourceCreateImageAtIndex(…)方法生成图片，此方法的参数可以设置立即缓存图片解码后的数据，如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)createBitmapWithImage:(UIImage*)image {
    NSData *data = UIImagePNGRepresentation(image);
    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);
    CGImageRef bitmapImageRef = CGImageSourceCreateImageAtIndex(source, 0, (__bridge CFDictionaryRef)@{(id)kCGImageSourceShouldCacheImmediately: (id)kCFBooleanTrue});
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述两种方式都是直接在内存中对图片进行解码，还有第三种方式，它是在把图片保存到本地时，以位（kUTTypeBMP）的形式保存，看代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)saveBitmapWithImage:(UIImage*)image {
    NSString *localPath = [NSString stringWithFormat:@&quot;%@testimage.bitmap&quot;, NSTemporaryDirectory()];
    CFURLRef url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,  (__bridge CFStringRef)localPath, kCFURLPOSIXPathStyle, false);
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL(url, kUTTypeBMP, 1, 0);
    CGImageDestinationAddImage(destination, image.CGImage, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.cnbang.net/tech/2578/&quot;&gt;iOS图片加载速度极限优化—FastImageCache解析 «  bang’s blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;http://www.cairuitao.com/fastimagecache源码分析/&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/mg0832058/article/details/5890688&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gordon0918/p/5280589.html&quot;&gt;linux进程间通信之共享内存篇 - Gordon0918 - 博客园&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25706397/cgimageref-width-doesnt-agree-with-bytes-per-row&quot;&gt;osx - CGImageRef width doesn’t agree with bytes-per-row - Stack Overflow&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Sep 2017 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2017/09/%E7%B1%BB%E4%BC%BC%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB%E6%88%96%E8%80%85tableView%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%89%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%E9%9C%80%E6%B1%82%E7%9A%84%E5%9C%BA%E6%99%AF%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/09/%E7%B1%BB%E4%BC%BC%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB%E6%88%96%E8%80%85tableView%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%89%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%E9%9C%80%E6%B1%82%E7%9A%84%E5%9C%BA%E6%99%AF%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/</guid>
        
        <category>iOS | 优化</category>
        
        
      </item>
    
      <item>
        <title>iOS优化界面渲染实践中的几点经验</title>
        <description>&lt;h2 id=&quot;一圆角切割&quot;&gt;一、圆角切割&lt;/h2&gt;
&lt;p&gt;离屏渲染这个词已经老生常谈了，常说的圆角（切割）、遮罩mask、阴影shadow都会导致GPU离屏渲染，好在apple在iOS9以后优化了圆角切割，不再会导致离屏渲染了，但事实&lt;strong&gt;并不是&lt;/strong&gt;这样的。&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;场景&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2017-7-15/RoomUI_123.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如我们直播间上方的观众列表中的圆形头像，在iOS10.3.2系统上用Instruments查看，还是有用黄色阴影标记的离屏渲染，而且由于直播间这种特殊场景，背景视频始终在渲染，这些圆角也就&lt;strong&gt;始终&lt;/strong&gt;在离屏渲染，让人捉急。&lt;/p&gt;

&lt;p&gt;我各种猜想及google均无果（有人说设置imageView的backgroundColor会引起但我们的观众头像并没有设置），最后发现是imageView的contentMode属性在作怪，把contentMode恢复成默认的ScaleToFill就好了，当然改动是在不影响显示效果的情况下。同时我也尝试了设置imageView的backgroundColor同样也会引起圆角切割的离屏渲染。&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;所以得出结论，在iOS9+上使用UIImageView并做了圆角切割的时候，&lt;strong&gt;contentMode&lt;/strong&gt;属性和&lt;strong&gt;backgroundColor&lt;/strong&gt;属性尽量使用默认值来避免GPU离屏渲染。&lt;/p&gt;

&lt;h2 id=&quot;二遮罩mask&quot;&gt;二、遮罩mask&lt;/h2&gt;
&lt;h3 id=&quot;场景-1&quot;&gt;场景&lt;/h3&gt;
&lt;p&gt;同样老生常谈，发现问题的场景是我们直播间的某个大动画，播放期间满屏的离屏渲染，看了下代码发现用了好多的mask。捋了下动画中有关某个元素的mask效果，是想用mask做一个元素渐渐出现的效果，其实这个效果用一个不透明的图层盖在元素上面也可以做到，不过没有mask使用起来方便，但是对于GPU来说合成图层比离屏渲染要轻松很多。&lt;/p&gt;
&lt;h3 id=&quot;结论-1&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;所以得出结论，遮罩mask尽量避免使用，用图层合成的方式来代替，但必须承认有些效果是图层合成代替不了的。&lt;/p&gt;

&lt;h2 id=&quot;三hidden-vs-opacity&quot;&gt;三、hidden VS opacity&lt;/h2&gt;
&lt;h3 id=&quot;场景-2&quot;&gt;场景&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2017-7-15/RoomUI_234.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一个莫名图层引发的血案，场景是这样的，直播间每当有进场动画的时候，都会从屏幕的左边划出一个离屏渲染的莫名图层。经过尝试发现造成这个问题的原因是CALayer的hidden属性，在给layer做动画的同时，&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)animationDidStart:(CAAnimation *)anim&lt;/code&gt;触发了layer.hidden属性的变化，造成离屏渲染莫名图层。&lt;/p&gt;

&lt;p&gt;关于hidden造成离屏渲染，其实挺有意思，可以自己写个小demo，就单纯的点击一个按钮把一个layer的hidden设为NO（之前为YES），就可以观察到离屏渲染，而且是以屏幕的左上角为原点，一直延伸到这个layer所在的区域，也可以推断出系统处理hidden属性的机制，就是离屏渲染这片区域。&lt;/p&gt;

&lt;p&gt;那么如何避免设置hidden属性呢，第一个想到的是在需要的时候add上，不需要时直接remove掉，但是尝试过后发现还是会引起离屏渲染，只是渲染的区域不一样了（只渲染layer的superLayer的区域，比设置hidden造成的影响小），因此可以推测hidden本质上也是remove。&lt;/p&gt;

&lt;p&gt;再有一个思路就是用设置opacity来代替设置hidden，经过测试发现离屏渲染消失了！来自stackoverflow的答案也可以佐证：&lt;code class=&quot;highlighter-rouge&quot;&gt;This is the best choice, because setting hidden to true removes view from the render loop. While setting alpha to 0 just makes view transparent.&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;结论-2&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;所以得出结论，用设置opacity来代替设置hidden性能更佳。&lt;/p&gt;

&lt;h2 id=&quot;四calayer-vs-drawrect&quot;&gt;四、CALayer VS drawRect&lt;/h2&gt;
&lt;p&gt;这其实是一个平衡的思想，GPU与CPU与内存之间的平衡。我的经验是APP瓶颈往往在CPU，所以总是会想一些办法去转移本该在CPU上的工作。&lt;/p&gt;
&lt;h3 id=&quot;场景-3&quot;&gt;场景&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/2017-7-15/RoomUI_345.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;场景是这样的，我们直播间连送动画中的”x次数”的文本目前是通过重写UILabel的drawRect方法实现的，drawRect这个方法其实是最不建议使用的，它既牵扯到开辟新的内存空间（而且似乎还是挺大的空间），也牵扯到过多的利用CPU去绘制。&lt;/p&gt;

&lt;p&gt;我猜想当初选择这个方法实现的原因可能是文字有渐变色的要求，还有阴影的要求。其实这样的需求可以通过CAGradientLayer和CATextLayer再配合一层CALayer做阴影效果来实现（下面有实现代码），这个方案相对于之前的方案在CPU和内存的表现上很不错，原因就是apple提供的各种CAxxxLayer是做过专门优化（硬件加速）的，所谓硬件加速应该就是充分利用了GPU的计算能力吧。&lt;/p&gt;

&lt;p&gt;改进后的方案如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define mColor(hex, a) [UIColor colorWithRed:(((hex)&amp;gt;&amp;gt;16 &amp;amp; 0xff) / 255.f) green:(((hex)&amp;gt;&amp;gt;8 &amp;amp; 0xff) / 255.f) blue:(((hex)&amp;amp;0xff) / 255.f) alpha:(a)]

    CAGradientLayer *gradientLayer = [CAGradientLayer layer];
    gradientLayer.frame = CGRectMake(50, 100, 200, 50);
    gradientLayer.colors = @[(id)mColor(0xFFEE71, 1).CGColor, (id)mColor(0xF4B60F, 1).CGColor];;
    
    CATextLayer *textLayer = [CATextLayer layer];
    textLayer.frame = gradientLayer.bounds;
    textLayer.font = (__bridge CFTypeRef _Nullable)(font);
    textLayer.fontSize = 27;
    textLayer.contentsScale = [UIScreen mainScreen].scale;
    textLayer.string = @&quot;Hulk Rong&quot;;
    
    gradientLayer.mask = textLayer;
    
    CALayer* containerLayer = [CALayer layer];
    containerLayer.shadowColor = [UIColor blackColor].CGColor;
    containerLayer.shadowOffset = CGSizeMake(0, 1);
    containerLayer.shadowRadius = 0;
    containerLayer.shadowOpacity = 0.3;
    [containerLayer addSublayer:gradientLayer];
    [self.view.layer addSublayer:containerLayer];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还有一个常见场景是有时我们需要使用贝塞尔曲线（UIBezierPath）去绘制，也是下意识的去重写drawRect方法，其实设置CAShapeLayer的path属性交由GPU来渲染就可以了，同样会在CPU和内存上有不错的表现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;其实，如果能用一张设计给的图片来代替我们写代码去绘制是最好的了！&lt;/p&gt;
&lt;h3 id=&quot;tips&quot;&gt;Tips&lt;/h3&gt;
&lt;p&gt;在做实验的时候还有个有趣的发现，通过CALayer这种方式，在不断的使用相同的图层的时候，发现一段时间后内存会升到跟直接用CPU绘制时的内存差不多的情况，我猜想这也是系统做的优化，把不断重复使用的图层缓存起来了。&lt;/p&gt;
&lt;h3 id=&quot;结论-3&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;所以得出结论，瓶颈在CPU或者内存的时候，尽量通过各种CALayer的实现来代替重写drawRect方法，把工作转移到GPU上去。&lt;/p&gt;

&lt;h2 id=&quot;五光栅化shouldrasterize&quot;&gt;五、光栅化shouldRasterize&lt;/h2&gt;
&lt;p&gt;这个特性也牵扯到平衡的思想所以顺带一提，它是通过消耗内存来减轻GPU的计算压力，至于能不能减轻CPU的压力还是要看具体的场景。&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;光栅化是CPU将目标layer（及其所有的子layer渲染后的图层）生成一张bitmap缓存起来，再次用到时直接渲染缓存的bitmap就行，省去了CPU频繁绘制或者GPU的合成计算。这个特性适用于在使用期间不会变化的layer（变化的话缓存就不会被命中，Instruments有专门检测这个缓存是否命中的工具），如果在子layer层级很多或者有文本需要CPU绘制的情况下优化效果会好一些，可以减少GPU的图层合成计算，减少CPU的绘制工作（但是需要CPU来生成缓存的bitmap），转嫁到内存上。&lt;/p&gt;
&lt;h3 id=&quot;场景-4&quot;&gt;场景&lt;/h3&gt;
&lt;p&gt;直播间的公聊区域需要展示大量的文本，iOS中凡是牵扯到文本的其实都是CPU利用Core Text这个库来绘制的，包括系统的UILabel、UITextField等控件。那么公聊区域就会大量消耗CPU的资源。分析一下我们的公聊区域，首先满足一条消息的图层在展示过程中是不变的，其次消息也就是文本（还会嵌入图片），需要CPU频繁绘制文本，因为没有复杂的图层本身不需要GPU做太多合成计算所以忽略GPU，那么打开shouldRasterize&lt;strong&gt;或许&lt;/strong&gt;可以为CPU减压。&lt;/p&gt;
&lt;h3 id=&quot;结论-4&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;上面之所以说是&lt;strong&gt;或许&lt;/strong&gt;，我觉得是掌握这个属性的关键所在，因为根据原理推断在满足一定条件的前提下，打开shouldRasterize是一定能够减少GPU对于图层合成的计算量，但是对于CPU来说，有减少也有增加，最后净减少是正还是负还需要依据具体的场景通过Instruments来实际测量。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我觉得每一篇分享都是抛砖引玉，分享了简单的原理和碰到过的场景，但是还有很多使用场景需要集思广益，很多新的细节需要我们去发现，希望我们多多交流，共同进步。&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jul 2017 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/iOS%E4%BC%98%E5%8C%96%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E5%87%A0%E7%82%B9%E7%BB%8F%E9%AA%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/iOS%E4%BC%98%E5%8C%96%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E5%87%A0%E7%82%B9%E7%BB%8F%E9%AA%8C/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS UI Tests 实现方案分析</title>
        <description>&lt;p&gt;UI Tests是一个可以对UI进行测试的框架。为什么需要UI Tests呢？如果客户端分为基础层和业务层的话，业务层最终都是负责界面展示的，通常是MV(C/P/VM)，(C/P/VM)中的逻辑并不适合用Unit Tests来覆盖。对于具体的界面操作流程，UI Tests是合适的选择。&lt;/p&gt;

&lt;h2 id=&quot;集成ui-tests&quot;&gt;集成UI Tests&lt;/h2&gt;
&lt;p&gt;下图为在Xcode中为项目添加UI Tests的步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;新建Target
&lt;img src=&quot;/assets/images/2017-7-6/UITests_AddBuddle.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;新建Case Class
&lt;img src=&quot;/assets/images/2017-7-6/UITests_AddCaseClass.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2017-7-6/UITests_CaseClass.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;writing-ui-tests&quot;&gt;Writing UI Tests&lt;/h2&gt;
&lt;h3 id=&quot;recording&quot;&gt;Recording&lt;/h3&gt;
&lt;p&gt;Xcode为我们提供了把整套操作转化为代码的功能，见下图：
&lt;img src=&quot;/assets/images/2017-7-6/UITests_XcodeRecording.png&quot; alt=&quot;&quot; /&gt;
几个关键点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法名必须以&lt;strong&gt;test&lt;/strong&gt;开头，所在行的开头才会有一个菱形的标记，标志这个方法可以被测试。&lt;/li&gt;
  &lt;li&gt;满足上一个条件后，把光标放在方法体内，Xcode下方的Debug area的红点就会亮起，点击这个红点就会启动APP，开始录制操作并同步生成代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是我录制的从打开应用——&amp;gt;打开直播间——&amp;gt;在直播间发言”大家好！”的过程中生成的代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)testSpeakInLiveRoom {
[XCUIDevice sharedDevice].orientation = UIDeviceOrientationFaceUp;
[XCUIDevice sharedDevice].orientation = UIDeviceOrientationFaceUp;
[XCUIDevice sharedDevice].orientation = UIDeviceOrientationFaceUp;
[XCUIDevice sharedDevice].orientation = UIDeviceOrientationFaceUp;
[XCUIDevice sharedDevice].orientation = UIDeviceOrientationPortrait;

XCUIApplication *app = [[XCUIApplication alloc] init];
[app.tabBars.buttons[@&quot;tab launch&quot;] tap];
[app.buttons[@&quot;\U76f4\U64ad&quot;] tap];
[app.buttons[@&quot;\U5f00\U59cb\U76f4\U64ad&quot;] tap];
[app.buttons[@&quot;mg room btn liao h&quot;] tap];

XCUIApplication *app2 = app;
[app2.buttons[@&quot;\U5927\U5bb6\U597d&quot;] tap];
[app2.buttons[@&quot;\Uff01&quot;] tap];
[[[app childrenMatchingType:XCUIElementTypeWindow] elementBoundByIndex:0].buttons[@&quot;\U53d1\U9001&quot;] tap];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Xcode自动生成的代码中的Unicode为”\Uxxxx”会报错，把”\U”替换为”\u”就可以了。&lt;/p&gt;

&lt;p&gt;把其中的Unicode转义一下，并且精简下冗余的代码后，是这样的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)testSpeakInLiveRoom {
[XCUIDevice sharedDevice].orientation = UIDeviceOrientationPortrait;

XCUIApplication *app = [[XCUIApplication alloc] init];
[app.tabBars.buttons[@&quot;tab launch&quot;] tap];
[app.buttons[@&quot;直播&quot;] tap];
[app.buttons[@&quot;开始直播&quot;] tap];
[app.buttons[@&quot;mg room btn liao h&quot;] tap];
[app.buttons[@&quot;大家好&quot;] tap];
[app.buttons[@&quot;！&quot;] tap];
[[[app childrenMatchingType:XCUIElementTypeWindow] elementBoundByIndex:0].buttons[@&quot;发送&quot;] tap];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:这段精简的代码已经满足我们正常的阅读了，但要用于生产环境还有很大的优化空间，后面会讲到。&lt;/p&gt;

&lt;h3 id=&quot;apis&quot;&gt;APIs&lt;/h3&gt;
&lt;p&gt;通过上述Xcode自动生成并且经过我们简单修改的代码，其实已经一目了然了，启动程序后，通过API获取相应的界面元素集合，并筛选出需要的元素（如何筛选？见下一小节），然后触发一系列操作。下面是UI Tests依赖的三个类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;XCUIApplication&lt;/li&gt;
  &lt;li&gt;XCUIElement&lt;/li&gt;
  &lt;li&gt;XCUIElementQuery (实现了XCUIElementTypeQueryProvider协议)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;筛选-with-accessibility&quot;&gt;筛选 With Accessibility&lt;/h3&gt;
&lt;p&gt;关于Accessibility，以下是apple Developer上的介绍：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Accessibility is the core technology that allows disabled users the same rich experience for iOS and macOS that other users receive. It includes a rich set of semantic data about the UI that users can use can use to guide them through using your app. Accessibility is integrated with both UIKit and AppKit and has APIs that allow you to fine-tune behaviors and what is exposed for external use. ~UI testing uses that data to perform its functions.~
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Accessibility是iOS提供用来服务于残障人士的API，比如一位盲人在使用你的APP，当他点击到一个按钮时，系统会自动播放这个按钮的名称/用途，就是通过accessibilityLabel这个属性实现的。我们可以在编写应用界面时设置这些属性。&lt;/p&gt;

&lt;p&gt;同时，UI Tests也会用到Accessibility。上面Xcode自动生成的UI Tests的代码中，从元素集合app.buttons中获取/筛选一个button就是用accessibilityLabel作为下标实现的，但是如果我们自己去写UI Tests，不建议使用accessibilityLabel，而应该使用accessibilityIdentifier，因为上面已经说了accessibilityLabel更倾向用于提供名称，Xcode在UI Testing过程中可能在一个场景中有两个控件的accessibilityLabel是相同的就会报错，而accessibilityIdentifier才是唯一的ID。系统之所以使用前者可能是因为accessibilityIdentifier这个属性默认值是nil。（可以通过Xcode分别定位到这两个属性的定义来查看描述信息和默认值，辅助理解）&lt;/p&gt;

&lt;h3 id=&quot;断言&quot;&gt;断言&lt;/h3&gt;
&lt;p&gt;利用XCTest提供的XCTAssert APIs，编写符合期望的断言。比如在上述代码示例的最后，可以加入一个断言来判断”发送”的内容是否成功显示，就完成了对”发送”这个功能的测试。&lt;/p&gt;

&lt;p&gt;这里值得一提的是，有些时候我们并不希望立即进行断言（比如进入直播间后要等上几秒一些功能的网络请求才会返回），这时就会用到XCTestCase提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)waitForExpectations:(NSArray&amp;lt;XCTestExpectation *&amp;gt; *)expectations timeout:(NSTimeInterval)seconds;&lt;/code&gt;系列方法，在规定的时间范围内不断轮询检查。&lt;/p&gt;

&lt;h3 id=&quot;查看报告&quot;&gt;查看报告&lt;/h3&gt;
&lt;p&gt;上文的配图中提到过的在每个测试方法的开头有个菱形标志，在UI Tests跑完后，不论通过与否，你都可以通过右击菱形标志看到”Jump to Report”选项，点击就可以看到本次测试这个方法的具体流程了，查看报告有益于我们了解测试流程以及迅速定位问题所在。&lt;/p&gt;

&lt;h2 id=&quot;实践难点&quot;&gt;实践难点&lt;/h2&gt;
&lt;p&gt;经过我初步的实践和判断，在目前的项目中集成UI Tests有以下几个难点：&lt;/p&gt;
&lt;h3 id=&quot;1筛选筛选筛选&quot;&gt;1、筛选、筛选、筛选&lt;/h3&gt;
&lt;p&gt;上一节已经讲了如何筛选，但是想科学筛选还是需要一定的实践。UI Tests无非就是筛选—&amp;gt;触发—&amp;gt;断言，目前来看最麻烦的就是筛选这个环节。通过上述示例代码或者自己动手去录制一段代码，会发现想找到一个指定的元素Xcode会利用accessibilityLabel沿着当前view的层级逐层去定位，跟view层级绑定起来简直是一件很糟的事情，意味着你需要去熟悉凡是牵扯到的功能的view层级还得在UI变动时及时调整筛选代码，好在apple的初衷不是这样的，XCUIElementQuery实现了XCUIElementTypeQueryProvider协议，使得我们可以通过控件的ElementType（XCUIElementTypeQueryProvider中有定义）和accessibilityIdentifier轻松定位到，不再关心所到之处view的层级，见代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Xcode生成的
[[[app childrenMatchingType:XCUIElementTypeWindow] elementBoundByIndex:0].buttons[@&quot;发送&quot;] tap];

//改进后
[app.buttons[按钮的accessibilityIdentifier] tap];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;：
也有特例，比如系统控件AlertView、ActionSheet等，我们只可以定义按钮名称，想要设置accessibilityIdentifier还要另辟蹊径，这时倒是可以采用上述Xcode的方式（利用accessibilityLabel沿着当前view的层级逐层去定位）来做，见代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//accessibilityIdentifier定位的方式
app.buttons[@&quot;button的accessibilityIdentifier&quot;];

//由于系统ActionSheet的button并不公开，设置accessibilityIdentifier不可行。
//利用accessibilityLabel沿着当前view的层级逐层去定位的方式
app.sheets.buttons[@&quot;踢出直播间24小时&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;也就是说这两个方式都有用武之地，还是要看具体的场景和需求，有待挖掘。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;还有一点值得一提，&lt;/strong&gt; 上面说的XCUIElementTypeQueryProvider协议会提供各种类型的XCUIElementQuery，但是使用后我们发现这些类型跟我们UIKit的控件类型并不是一一对应的，比如UIView或者UIImageView，并不能像UIButton那样默认可以在XCUIElementTypeQueryProvider 的&lt;code class=&quot;highlighter-rouge&quot;&gt;buttons&lt;/code&gt;集合里找到。不用急，Accessibility API里还提供了一个属性&lt;code class=&quot;highlighter-rouge&quot;&gt;accessibilityTraits&lt;/code&gt;来帮我们完成UIKit控件的归类，比如一个UIImageView，如果在某个场景下可以被点击，我们可以把它的&lt;code class=&quot;highlighter-rouge&quot;&gt;accessibilityTraits&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAccessibilityTraitButton&lt;/code&gt;，就可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;buttons&lt;/code&gt;里找到了。如果在某个场景下只是用来展示图片的，可以把它的&lt;code class=&quot;highlighter-rouge&quot;&gt;accessibilityTraits&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAccessibilityTraitImage&lt;/code&gt;，就可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;images&lt;/code&gt;里找到了。如果你不知道应该设置成什么，就用&lt;code class=&quot;highlighter-rouge&quot;&gt;UIAccessibilityTraitNone&lt;/code&gt;，对应XCUIElementTypeQueryProvider中的&lt;code class=&quot;highlighter-rouge&quot;&gt;otherElements;&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2accessibilityidentifier管理&quot;&gt;2、accessibilityIdentifier管理&lt;/h3&gt;
&lt;p&gt;整个APP中的每个控件都需要一个唯一的accessibilityIdentifier（或者至少是同一个ElementType的accessibilityIdentifier不能相同），这个需要制定规范统一管理。我们目前采取的方案是用控件所在类的类名+控件变量名作为accessibilityIdentifier。&lt;/p&gt;

&lt;h3 id=&quot;3逻辑复用多人协作&quot;&gt;3、逻辑复用、多人协作&lt;/h3&gt;
&lt;p&gt;一个大型APP一定是多团队多人协作，并且很多功能的测试都依赖一些公共的逻辑，你可能只是想为直播间内一个新功能（比如小活动展示功能）添加UI Tests，但是需要涉及从打开应用到进入直播间的整段逻辑，这里就需要统一的封装，比如开直播这个功能可以统一封装，所有需要开直播的流程都可以调用。&lt;/p&gt;

&lt;p&gt;对于第2、3两点我在项目中的实践：
&lt;img src=&quot;/assets/images/2017-7-6/UITests_封装.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4ui频繁变动&quot;&gt;4、UI频繁变动&lt;/h3&gt;
&lt;p&gt;几个星期一个版本迭代，意味着UI一定是在不断变化，想要完善的UI Tests，就需要开发人员养成在UI变动时及时调整UI Tests的习惯。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;上面说了这么多，总结下来，就诞生了这段优化之后的示例代码（用的还是accessibilityLabel请忽略）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)testSpeakInLiveRoom {
[XCUIDevice sharedDevice].orientation = UIDeviceOrientationPortrait;
XCUIApplication *app = [[XCUIApplication alloc] init];
[self _openLive:app];
[app.buttons[@&quot;mg room btn liao h&quot;] tap];
NSString *text = [NSString stringWithFormat:@&quot;%f : 大家好！&quot;, [[NSDate date] timeIntervalSince1970]];
[app.textFields[@&quot;和大家说点什么&quot;] typeText:text];
[app.buttons[@&quot;发送&quot;] tap];

NSString *showText = [NSString stringWithFormat:@&quot;Hulk Rong:%@&quot;,text];
XCTAssertTrue(app.tables.staticTexts[showText].exists);
}

- (void)_openLive:(XCUIApplication*)app {
[app.buttons[@&quot;tab launch&quot;] tap];
[app.buttons[@&quot;直播&quot;] tap];
[app.buttons[@&quot;开始直播&quot;] tap];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;:来自apple Developer的UI Tests编写思路：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use an XCUIElementQuery to find an XCUIElement.&lt;/li&gt;
  &lt;li&gt;Synthesize an event and send it to the XCUIElement.&lt;/li&gt;
  &lt;li&gt;Use an assertion to compare the state of the XCUIElement against an expected reference state.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;抛砖引玉&quot;&gt;抛砖引玉&lt;/h2&gt;
&lt;p&gt;说了这么多，基本把写一个简单的UI Tests需要知道的都说了。接下来我写几个自己想到的例子，代码在我们的工程中都有，算是抛砖引玉。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;测试直播间发言是否成功，也就是本篇的示例代码。步骤是打开应用—&amp;gt;开直播—&amp;gt;发言—&amp;gt;判断公聊区是否有发言内容。&lt;/li&gt;
  &lt;li&gt;测试直播间商业红包步骤是否正确，这个我已经在项目中实现。步骤是打开应用—&amp;gt;开直播—&amp;gt;（手动触发直播间红包）—&amp;gt;判断红包是否展示—&amp;gt;判断跟红包位置冲突的活动轮播图是否已经隐藏—&amp;gt;点击红包判断是否弹出提示弹窗—&amp;gt;……—&amp;gt;红包倒计时结束后是否显示”发放中”—&amp;gt;……..等&lt;/li&gt;
  &lt;li&gt;测试直播间是否有热门火箭。步骤是打开应用—&amp;gt;开直播—&amp;gt;判断直播间是否有小火箭的view。（这块完整的测试还应该包括火箭被点击前后的位置变化是否正确、使用火箭的流程中各个view的出现时机和位置是否正确、使用后的提示是否正确）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;畅想&quot;&gt;畅想&lt;/h2&gt;
&lt;p&gt;如果一个功能有全面合理的UI Tests覆盖，那么假如基础架构进行了重构，假如某一块业务进行了重构，假如…，你所担心的，都只需跑一遍UI Tests心里就有个大概了，如果再辅以Unit Tests，再也不怕改变带来的未知恐惧了，还给测试大大减少了负担。惊喜不惊喜，意外不意外？&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/09-ui_testing.html#//apple_ref/doc/uid/TP40014132-CH13-SW1&quot;&gt;User Interface Testing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://onevcat.com/2015/09/ui-testing/&quot;&gt;WWDC15 Session笔记 - Xcode 7 UI 测试初窥&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/imgur-engineering/adding-ui-testing-to-an-existing-ios-app-e0e440ca213d&quot;&gt;Adding UI Testing to an existing iOS App&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Jul 2017 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/iOS-UI-Tests-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/iOS-UI-Tests-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</guid>
        
        <category>iOS | Test</category>
        
        
      </item>
    
      <item>
        <title>iOS Unit Tests 实现方案分析</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;solid&quot;&gt;S.O.L.I.D&lt;/h2&gt;
&lt;p&gt;理解单元测试，首先要理解单元(Unit)：软件设计的最小单位，而在我们面向对象的世界里最小单位就是方法，所以好的单元测试一定很好的覆盖了方法。想覆盖就得有暴露，如果一个类包含了本应该设计成三个类的代码，首先它是不OOP的，其次它也是不可单元测试的（除非暴露私有方法）。所以好的代码结构和好的单元测试是相辅相成，互相依赖的。所以在文章的开始需要强调一下基础，面向对象的五大原则SOLID：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;S - 单一职责原则，类的功能应该单一。&lt;/li&gt;
  &lt;li&gt;O - 开放封闭原则，对扩展开放，对修改封闭。&lt;/li&gt;
  &lt;li&gt;L - 里氏替换原则，子类可以完全代替父类在程序中运行。&lt;/li&gt;
  &lt;li&gt;I - 接口隔离原则，客户端不应去实现它们不需要的接口。&lt;/li&gt;
  &lt;li&gt;D - 依赖倒置原则，依赖于抽象而不是具体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tdd-or-bdd-&quot;&gt;TDD or BDD ?&lt;/h2&gt;
&lt;h3 id=&quot;tdd&quot;&gt;TDD&lt;/h3&gt;
&lt;p&gt;Test-driven development，测试驱动开发。
在我们设计一个类时，首先需要考虑这个类能提供什么功能以及如何提供，也就是这个类公开的方法。TDD的做法是先为这些公开的方法写测试代码，肯定一开始测试是通不过的，接下来开发人员的目的就是写代码实现类功能来让测试通过，测试通过了，这个类也就实现好了。&lt;/p&gt;

&lt;h3 id=&quot;bdd&quot;&gt;BDD&lt;/h3&gt;
&lt;p&gt;Behavior-driven development，行为驱动开发。
TDD的目的是测试每个公开方法的正确性，而BDD关注的是行为，BDD的测试过程是以陈述需求的方式进行的（Given..When..Then），所以更友好，也更接近实际需求。&lt;/p&gt;

&lt;h3 id=&quot;举个栗子&quot;&gt;举个栗子&lt;/h3&gt;
&lt;p&gt;在实现直播间内活动挂件按优先级显示的功能时，我们需要维护一个描述view具体信息的model的集合类来保存当前直播间所有view的情况以便调整，它需要满足以下四个功能：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//添加
-(void)addModel:(RHShowPriorityModel*)model;
//删除
-(void)removeModel:(RHShowPriorityModel*)model;
//通过view索引model
-(RHShowPriorityModel*)modelForView:(UIView*)view;
//通过position索引model
-(NSArray&amp;lt;RHShowPriorityModel*&amp;gt;*)modelsForPosition:(RHShowPriorityPosition)position;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以TDD的思想&lt;/strong&gt;编写测试的话，就是聚焦到每一个公开的方法，设法进行全面的测试，我们使用官方的XCTest框架进行演练，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setUp {
    [super setUp];
    
    self.modelA = [[RHShowPriorityModel alloc] init];
    self.viewA = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
    _modelA.view = _viewA;
    _modelA.position = RHShowPriorityPositionLeftUp;
    
    self.modelB = [[RHShowPriorityModel alloc] init];
    self.viewB = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
    _modelB.view = _viewB;
    _modelB.position = RHShowPriorityPositionLeftUp;
    
    self.collection = [[RHShowPriorityCollection alloc] initWithModels:[NSArray arrayWithObjects:_modelA, _modelB, nil]];
}

- (void)tearDown {
    [super tearDown];
}


-(void)testModelForView {
    XCTAssertEqual([_collection modelForView:_viewA], _modelA);
    XCTAssertEqual([_collection modelForView:_viewB], _modelB);
}

-(void)testModelsForPosition {
    NSArray *array = [_collection modelsForPosition:RHShowPriorityPositionLeftUp];
    XCTAssertTrue([array isKindOfClass:[NSArray class]]);
    XCTAssertEqual(array[0], _modelA);
    XCTAssertEqual(array[1], _modelB);
}

-(void)testAddAndRemoveModel {
    RHShowPriorityModel *addModel = [[RHShowPriorityModel alloc] init];
    UIView *addView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 150, 150)];
    addModel.view = addView;
    XCTAssertNil([_collection modelForView:addView]);
    
    //test addModel
    [_collection addModel:addModel];
    XCTAssertEqual([_collection modelForView:addView], addModel);
    
    //test removeModel
    [_collection removeModel:addModel];
    XCTAssertNil([_collection modelForView:addView]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以BDD的思想&lt;/strong&gt;进行测试的话，应该聚焦到需求，可以试着以Given..When..Then的方式陈述一下我们对于这个集合类的需求，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;给你一个Coloection类，当它被初始化后，应该包含0个元素&lt;/code&gt;。我们使用比较热门的Kiwi框架&lt;a href=&quot;https://github.com/kiwi-bdd/Kiwi&quot;&gt;GitHub - kiwi-bdd/Kiwi: Simple BDD for iOS&lt;/a&gt; 进行演练，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;describe(@&quot;RHShowPriorityCollection&quot;, ^{
    context(@&quot;当用初始数据modelA和modelB进行初始化后&quot;, ^{
        __block RHShowPriorityCollection *collection = nil;
        RHShowPriorityModel *modelA = [[RHShowPriorityModel alloc] init];
        UIView *viewA = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
        modelA.view = viewA;
        modelA.position = RHShowPriorityPositionLeftUp;
        
        RHShowPriorityModel *modelB = [[RHShowPriorityModel alloc] init];
        UIView *viewB = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
        modelB.view = viewB;
        modelB.position = RHShowPriorityPositionLeftUp;
        
        beforeEach(^{
            collection = [[RHShowPriorityCollection alloc] initWithModels:[NSArray arrayWithObjects:modelA, modelB, nil]];
        });
        
        afterEach(^{
            collection = nil;
        });
        
        
        it(@&quot;通过viewA可以得到modelA，通过viewB可以得到modelB。&quot;, ^{
            [[[collection modelForView:viewA] should] equal:modelA];
            [[[collection modelForView:viewB] should] equal:modelB];
        });
        
        it(@&quot;通过一个位置可以得到一个数组，包含所有在这个位置的view的model。&quot;, ^{
            NSArray *array = [collection modelsForPosition:RHShowPriorityPositionLeftUp];
            [[array should] beKindOfClass:[NSArray class]];
            [[array[0] should] equal:modelA];
            [[array[1] should] equal:modelB];
        });
        
        it(@&quot;可以成功添加一个model。&quot;, ^{
            RHShowPriorityModel *addModel = [[RHShowPriorityModel alloc] init];
            UIView *addView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 150, 150)];
            addModel.view = addView;
            [[[collection modelForView:addView] should] beNil];
            [collection addModel:addModel];
            [[[collection modelForView:addView] should] equal:addModel];
        });
        
        it(@&quot;也可以成功删除一个model。&quot;, ^{
            [[[collection modelForView:viewB] shouldNot] beNil];
            [collection removeModel:modelB];
            [[[collection modelForView:viewB] should] beNil];
        });
        
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;惊不惊喜？反正在写的过程中我的内心是很舒服的，这段代码可以说是一目了然，清晰的陈述了我们对于这个类的要求，如果一位新同学要接手这块也是轻而易举。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;回到我们的项目我认为：&lt;/p&gt;

&lt;p&gt;对于像业务层的网络请求方法，只牵扯到基本的请求返回逻辑，测试也就只需要关注返回数据的正确与否，可以选择使用TDD的思想来做，也就是用官方的XCTest框架。&lt;/p&gt;

&lt;p&gt;对于像上文中描述的场景，承载一个功能的类，包含比较丰富的逻辑在里面，使用BDD的思想更合适，写起来舒服，读起来清晰。&lt;/p&gt;

&lt;h2 id=&quot;stubmock&quot;&gt;Stub、Mock&lt;/h2&gt;
&lt;p&gt;未完待续…&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Jul 2017 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/iOS-Unit-Tests-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/iOS-Unit-Tests-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</guid>
        
        <category>iOS | Test</category>
        
        
      </item>
    
      <item>
        <title>当我谈旅行时，我谈些什么</title>
        <description>&lt;h1 id=&quot;随心&quot;&gt;随心&lt;/h1&gt;

&lt;p&gt;在昆明的第二天，还有没去的但不想去的景点，心里总觉得憋得慌缺点啥，在云南大学周边转了一上午，吃过午饭后就彻底无聊烦躁到极点了，这才是旅途的第二天就这状态了，不合适啊。安静下来想了想，是因为昨天在滇池旁没玩够就去了民族村，本打算逛完民族村再去滇池旁诗意一会坐坐船看看西山风景，结果民族村太好玩导致逛完后体力都消耗殆尽了，加上阴天的昆明湿冷湿冷的，出了民族村我们就直接打道回府了，仿佛在心里种下了不痛快的种子，所以今天内心一直在那闹情绪，无聊烦躁没目的，像极了平常生活中那种麻木消极的状态。缕清想法后，毅然决然重游滇池，站在奔驰于滇池的小游轮观光台上欣赏美景，远处西山朦胧神秘，头顶红嘴鸥自由翱翔，阳光照进心里，昨天行走一天的疲惫消失了，中午的消极情绪也被风吹走了。痛快过后走在滇池旁的绿茵小道上，就有了写这篇游记的冲动，是的，只要遵从内心，冲动就会一个接一个，生活才有了动力，人生才有了意义，假使我像往常一样以各种理由拒绝了内心的那个想法，可想而知我今天中午以后的时光是怎样的：下午找个就近的地方无聊烦躁的度过，之后拉上沉重的行李拖上疲惫的身体来到火车站等待10点多的火车，消极情绪一直环绕，还得以各种麻醉剂一样的自我安慰来鼓励自己去享受接下来的美景，不会有在滇池上的痛快，也不会有痛快之后写这篇感悟的冲动，也不会有写完这篇感悟后…，或许可以联想一下我在车站等车时因为无聊烦躁指不定滋生出什么事，生活或许就完全拐到了另外一个方向去了。而因为我顺从了内心，可以利用这两个多小时等车的时间静下来写写东西，身旁的媳妇受我影响也自娱自乐起来，居然用一个简单的快餐勺子摆出了各种有意思的人脸表情，快有一个表情包了，简直创意十足！如果不是这样，或许她就是不断的刷微信刷微博还抱怨着无聊，想想简直糟透了。&lt;/p&gt;

&lt;h1 id=&quot;梦想&quot;&gt;梦想&lt;/h1&gt;

&lt;p&gt;既然开始写了，就把想说的都说了。这次来云南是&lt;code class=&quot;highlighter-rouge&quot;&gt;飞&lt;/code&gt;来的，本是件很正常的事，可对于我来说并不一般，因为这是我第一次坐飞机！以前是没有条件，后来有条件了却一直没有机会，这次终于飞起来了。想想自己这两年挺带劲的，前年把海看了，痛痛快快玩过几次（因为媳妇家在青岛），今年把飞机坐了，大海和飞机应该是小时候很向往的东西吧！犹记得一群小孩在操场上指着天空喊：飞机！飞机！尤其是在晚上看着一架闪着灯的飞机更是兴奋。现在也算是靠着自己的努力都亲身体验了，这里没有励志鸡血，就是告诉自己：用心生活，生活都会给你。&lt;/p&gt;

&lt;h1 id=&quot;膂力&quot;&gt;膂力&lt;/h1&gt;

&lt;p&gt;正好最近在看村上春树的《当我谈跑步时，我谈些什么》，膂力这个词就是从书里学到的，这两天旅途算是消化下这本书。我想强调的是耐力、专注力，或者是心力。不谈日常生活，单就旅途来说，在有限的时间和金钱下，我们的膂力决定我们看到的风景，或者说是接收到的风景。膂力强的人，每一次看到的更多一些，而一次次积累下来，就不是线性关系了，第一次多一点，第二次就多三点，第三次或许就直接多十点。所以说膂力带来的收获和成就是可观的。&lt;/p&gt;

&lt;p&gt;就像村上说的，这个世界上只有极少的人可以依靠天赋取得很大的成就，而大部分人靠的是膂力，起码前期靠的是膂力，到了一定阶段后或许会发现自己的独特之处从而取得成就，就像在贫瘠的土地上不断挖掘偶然发现了水源或是宝藏。所以说膂力是我们发现自我的基础。&lt;/p&gt;

&lt;h1 id=&quot;云南之行经验&quot;&gt;云南之行经验&lt;/h1&gt;

&lt;p&gt;这次我们的旅行路线是昆明-&amp;gt;大理-&amp;gt;丽江，走完这段后我总结出了大致的时间分配可以是这样的：&lt;/p&gt;

&lt;p&gt;昆明1天，路线是从大观楼-&amp;gt;滇池-&amp;gt;云南民族村，其中逛民族村需要3-4个小时。如果还想去西山，可以再拿出一天时间来。&lt;/p&gt;

&lt;p&gt;大理2天，在大理古城通过客栈老板找一个靠谱的团，让导游带你玩一天，可以了解大理的发展历程，白族人的风俗习惯，还可以看到天龙八部相关的东西，倚靠苍山洱海，遍地白族村寨的大理还是很美的！第一天下午可以直接去双廊，晚上住双廊的海景房，第二天从双廊出发，租个小电动沿洱海骑行，那风景简直了！&lt;/p&gt;

&lt;p&gt;丽江至少3天，第一天逛逛古城，下午可以去看丽江千古情表演，绝对震撼的表演。第二天去玉龙雪山，跟个纯玩团负责送你去雪山，你只负责玩就行，雪山的景色很不错！第三天可以去泸沽湖，因为现在丽江到泸沽湖那段正在修路，单程就需要8个小时！所以我们放弃了。但是几个月后那段高速就修好了，届时只需要两个小时就可以到泸沽湖，据同学说泸沽湖是很值得一去的。最后，如果时间充裕可以在这中间安排两天休息时间，在古城里悠哉两天也不错！&lt;/p&gt;

&lt;h1 id=&quot;写在最后&quot;&gt;写在最后&lt;/h1&gt;

&lt;p&gt;十天的云南之行结束了，结论是云南真的很美！值得一去。看了很多景，见了很多人，懂得生活可以有很多种姿势，尽管我还是喜欢自己这一种，随心用心走好每一步。&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Apr 2016 06:10:00 +0800</pubDate>
        <link>http://localhost:4000/2016/04/%E5%BD%93%E6%88%91%E8%B0%88%E6%97%85%E8%A1%8C%E6%97%B6-%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/04/%E5%BD%93%E6%88%91%E8%B0%88%E6%97%85%E8%A1%8C%E6%97%B6-%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</guid>
        
        <category>旅行</category>
        
        <category>跑步</category>
        
        
      </item>
    
      <item>
        <title>UIScrollView中draggin属性的延迟变化导致bug的解决方法</title>
        <description>&lt;p&gt;最近开始用Swift写项目，就先自己封装了下拉上拉的库&lt;a href=&quot;https://github.com/ronghaopger/EasyPull&quot;&gt;EasyPull&lt;/a&gt;上传到GitHub，期间跟网友交流解决了一些没考虑到的bug，现在库已经基本稳定了，我已经应用到生产中了。&lt;/p&gt;

&lt;p&gt;但是，在我不断的测试中，发现一个很隐晦的bug：在拉动到&lt;strong&gt;临界位置&lt;/strong&gt;左右释放后，有时不能触发刷新。随即我看了看手机上的常用应用，发现天猫、美团、今日头条等都存在这个问题，好奇之心涌上心头，一番debug后，发现罪魁祸首是UIScrollView的&lt;code class=&quot;highlighter-rouge&quot;&gt;draggin&lt;/code&gt;属性，官方的API有介绍：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dragging&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// returns YES if user has started scrolling. this may require some time and or distance to move to initiate dragging&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;draggin&lt;/code&gt;的变化有延迟，这就说明我们在用KVO对&lt;code class=&quot;highlighter-rouge&quot;&gt;contentOffset&lt;/code&gt;进行观察时，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;draggin&lt;/code&gt;的延迟，会有异常出现，前面的那个bug就是这个延迟导致的。&lt;/p&gt;

&lt;p&gt;发现问题了，如何解决呢？&lt;/p&gt;

&lt;p&gt;首先，我想到了去实现UIScrollViewDelegate，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;scrollViewDidEndDragging&lt;/code&gt;方法来做，事实证明它没有延迟，这样做是可以达到预期效果的，但这样又是不行的！因为作为第三方库去实现UIScrollViewDelegate会跟用户的实现冲突，导致总有一方不起作用。所以在写第三方库时这个思路是不可以的，如果不使用第三方库的话，这个思路还是可以的。&lt;/p&gt;

&lt;p&gt;到手的鸟飞了，不甘心，再加思索，能不能让我的库向系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;scrollViewDidEndDragging&lt;/code&gt;方法中注入一些我想要的逻辑呢？&lt;/p&gt;

&lt;p&gt;自然OC的动态运行时该出场了。代码是这样的：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AssociatedKeys&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;OnceToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;dispatch_once&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;AssociatedKeys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;OnceToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;originalSelector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;#selector(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:)&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;swizzledSelector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;#selector(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;UIViewController.easy_scrollViewDidEndDragging(_:willDecelerate:)&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;)&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;originalMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;classForCoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;originalSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;swizzledMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;classForCoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swizzledSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;didAddMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class_addMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;classForCoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;originalSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_getImplementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swizzledMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_getTypeEncoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swizzledMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;didAddMethod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;class_replaceMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;classForCoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swizzledSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_getImplementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originalMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_getTypeEncoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originalMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;method_exchangeImplementations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originalMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swizzledMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// MARK: - Method Swizzling&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;easy_scrollViewDidEndDragging&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;scrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIScrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;willDecelerate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;decelerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//self.easy_scrollViewDidEndDragging(scrollView, willDecelerate: decelerate) &lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//因为originalMethod不存在，所以swizzledSelector的方法交换就是失败的，再调用这句的结果就是死循环。&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;//TODO: 在符合特定条件的情况下，调用第三方库释放刷新的操作逻辑。保证操作能及时执行！&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个思路看似不错，逼格也高，但是认真看代码你会不会发现这个用法跟平时不太一样呢，我们交换的是UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:)的实现，UIScrollViewDelegate根本就没有实现，所以这段代码我们只是做到了给UIViewController增加了scrollViewDidEndDragging的实现。当用户在viewContrller里自己实现scrollViewDidEndDragging时，这个方法就失效了。&lt;/p&gt;

&lt;p&gt;还是不行，继续思考，发现就只有一个方法能做到最方便了，用户在自己的baseViewController里定义scrollViewDidEndDragging方法，就搞定。当然子类在需要时可以重写，但是记得super. scrollViewDidEndDragging。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BaseViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;.........&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;.........&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scrollViewDidEndDragging&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;scrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIScrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;willDecelerate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;decelerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//TODO: 在符合特定条件的情况下，调用第三方库释放刷新的操作逻辑。保证操作能及时执行！&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;搞定！&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Mar 2016 23:30:00 +0800</pubDate>
        <link>http://localhost:4000/2016/03/UIScrollView%E4%B8%ADdraggin%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8F%98%E5%8C%96%E5%AF%BC%E8%87%B4bug%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/03/UIScrollView%E4%B8%ADdraggin%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8F%98%E5%8C%96%E5%AF%BC%E8%87%B4bug%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
        
        <category>Swift | iOS</category>
        
        
      </item>
    
  </channel>
</rss>
